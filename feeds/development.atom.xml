<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Ashwini's blog - Development</title><link href="https://ashwch.com/" rel="alternate"></link><link href="https://ashwch.com/feeds/development.atom.xml" rel="self"></link><id>https://ashwch.com/</id><updated>2025-08-17T00:00:00-04:00</updated><entry><title>Insights from "Everything I Know About Good System Design"</title><link href="https://ashwch.com/insights-from-everything-i-know-about-good-system-design.html" rel="alternate"></link><published>2025-08-17T00:00:00-04:00</published><updated>2025-08-17T00:00:00-04:00</updated><author><name>Ashwini Chaudhary</name></author><id>tag:ashwch.com,2025-08-17:/insights-from-everything-i-know-about-good-system-design.html</id><summary type="html">&lt;p&gt;My thoughts and practical experiences applying Sean Goedecke's system design principles - from state management to database schemas, with real-world lessons learned over 10+ years.&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;The hard part about software design is state. If you're storing any kind of information for any amount of time, you have a lot of tricky decisions to make about how you save, store and serve it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I recently read Sean Goedecke's excellent piece on &lt;a href="https://www.seangoedecke.com/good-system-design/"&gt;system design principles&lt;/a&gt;, and it crystallized many lessons I've learned over 10+ years of building systems. Here are my key takeaways and how they've played out in practice.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="table-of-contents"&gt;&lt;a class="toclink" href="#table-of-contents"&gt;Table of Contents&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="#state-the-root-of-all-complexity"&gt;State: The Root of All Complexity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#database-design-get-the-schema-right"&gt;Database Design: Get the Schema Right&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#query-efficiency-let-the-database-work"&gt;Query Efficiency: Let the Database Work&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#background-processing-fast-vs-slow-operations"&gt;Background Processing: Fast vs. Slow Operations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#caching-choose-carefully"&gt;Caching: Choose Carefully&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#hot-paths-zero-margin-for-error"&gt;Hot Paths: Zero Margin for Error&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#logging-and-error-handling"&gt;Logging and Error Handling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#graceful-failure-the-hardest-problem"&gt;Graceful Failure: The Hardest Problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#the-pattern-recognition"&gt;The Pattern Recognition&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="state-the-root-of-all-complexity"&gt;&lt;a class="toclink" href="#state-the-root-of-all-complexity"&gt;State: The Root of All Complexity&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;State makes everything tricky. The more state we have, the harder it becomes to reason about our systems and keep track of responsibilities.&lt;/p&gt;
&lt;p&gt;On the flip side, statelessness relieves us of worrying about systems getting "stuck" or needing complex guardrails to prevent corruption.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You should try and minimize the amount of stateful components in any system.&lt;/p&gt;
&lt;p&gt;What this means in practice is having one service that knows about the state - i.e. it talks to a database - and other services that do stateless things. Avoid having five different services all write to the same table.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I'll admit this isn't something I actively think about - I might be doing it unconsciously in some cases and missing it entirely in others. But I want to keep an eye on this pattern in future projects.&lt;/p&gt;
&lt;h2 id="database-design-get-the-schema-right"&gt;&lt;a class="toclink" href="#database-design-get-the-schema-right"&gt;Database Design: Get the Schema Right&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Schema design should be flexible, because once you have thousands or millions of records, it can be an enormous pain to change the schema.
However, if you make it too flexible (e.g. by sticking everything in a "value" JSON column, or using "keys" and "values" tables to track arbitrary data) you load a ton of complexity into the application code (and likely buy some very awkward performance constraints).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I've always spent significant time on database design when building new systems, and it's consistently paid off. The JSON trap is real - while convenient initially, JSON fields create several problems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hard to query effectively&lt;/li&gt;
&lt;li&gt;Difficult to enforce schemas&lt;/li&gt;
&lt;li&gt;Serialization/deserialization overhead&lt;/li&gt;
&lt;li&gt;Network transfer costs for large payloads&lt;/li&gt;
&lt;li&gt;Additional validation complexity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That said, I've found JSON fields useful for storing external API payloads and validation errors - places where the structure truly varies.&lt;/p&gt;
&lt;h3 id="index-strategy"&gt;&lt;a class="toclink" href="#index-strategy"&gt;Index Strategy&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;If you expect your table to ever be more than a few rows, you should put indexes on it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I think the author didn't intend it, but &lt;strong&gt;index as you go&lt;/strong&gt;. If your table isn't showing slow queries yet, don't index prematurely. You can always add indices later and optimize them based on actual query patterns.&lt;/p&gt;
&lt;p&gt;I'm a big fan of PostgreSQL's &lt;code&gt;explain analyze&lt;/code&gt; - and with AI tools, analyzing query plans has become even more accessible.&lt;/p&gt;
&lt;h2 id="query-efficiency-let-the-database-work"&gt;&lt;a class="toclink" href="#query-efficiency-let-the-database-work"&gt;Query Efficiency: Let the Database Work&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;When querying the database, &lt;em&gt;query the database&lt;/em&gt;. It's almost always more efficient to get the database to do the work than to do it yourself. For instance, if you need data from multiple tables, &lt;code&gt;JOIN&lt;/code&gt; them instead of making separate queries and stitching them together in-memory. Particularly if you're using an ORM, beware accidentally making queries in an inner loop. That's an easy way to turn a &lt;code&gt;select id, name from table&lt;/code&gt; to a &lt;code&gt;select id from table&lt;/code&gt; and a hundred &lt;code&gt;select name from table where id = ?&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As a longtime Django user who's been reviewing Django code for 10+ years, I've seen the N+1 query problem countless times. It's crucial to educate your team on ORM fundamentals and maintain documentation of good vs. bad practices.&lt;/p&gt;
&lt;p&gt;Having a central document helps during code reviews - it's hard to repeatedly explain the "why" with the same depth. A shared resource makes linking to best practices much easier.&lt;/p&gt;
&lt;h2 id="background-processing-fast-vs-slow-operations"&gt;&lt;a class="toclink" href="#background-processing-fast-vs-slow-operations"&gt;Background Processing: Fast vs. Slow Operations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The goal is a fast request-response cycle for the best user experience. Operations that can't be completed quickly should move to background processing, with users notified when complete.&lt;/p&gt;
&lt;p&gt;This seems obvious, but determining what belongs in the background requires careful consideration of user expectations and system constraints.&lt;/p&gt;
&lt;h2 id="caching-choose-carefully"&gt;&lt;a class="toclink" href="#caching-choose-carefully"&gt;Caching: Choose Carefully&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Be selective about what and when to cache. Otherwise, you'll face the much harder problem of cache invalidation. The best solution is reducing the number of places using cache.&lt;/p&gt;
&lt;p&gt;Cache invalidation remains one of the hardest problems in computer science for good reason.&lt;/p&gt;
&lt;h2 id="hot-paths-zero-margin-for-error"&gt;&lt;a class="toclink" href="#hot-paths-zero-margin-for-error"&gt;Hot Paths: Zero Margin for Error&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I define hot paths as system components where downtime significantly affects our SLA - critical numbers, authentication, or features that directly impact business and users.&lt;/p&gt;
&lt;p&gt;These systems require extra care:
- World-class unit tests and coverage
- Attention to unhappy paths
- More conservative change management&lt;/p&gt;
&lt;p&gt;Take Instagram: it's more important for signed-in users to see their feed than for signup to work perfectly.&lt;/p&gt;
&lt;h2 id="logging-and-error-handling"&gt;&lt;a class="toclink" href="#logging-and-error-handling"&gt;Logging and Error Handling&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Beyond traditional logging, we utilize logs in unit tests to ensure they're not removed carelessly during updates. This makes log changes visible during code review.&lt;/p&gt;
&lt;p&gt;We also return custom error codes with responses - they help identify issues without log diving and assist both customers and developers debugging problems.&lt;/p&gt;
&lt;p&gt;For critical errors sent to monitoring tools like Sentry, we use custom exception names to quickly spot issue locations based on error messages.&lt;/p&gt;
&lt;h2 id="graceful-failure-the-hardest-problem"&gt;&lt;a class="toclink" href="#graceful-failure-the-hardest-problem"&gt;Graceful Failure: The Hardest Problem&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This ties back to state management. Building resilient state machines requires balancing when to fail, retry frequency, state resets, and maintaining manageable state complexity.&lt;/p&gt;
&lt;p&gt;It's one of the trickiest aspects of system design - fighting between reliability and simplicity.&lt;/p&gt;
&lt;h2 id="the-pattern-recognition"&gt;&lt;a class="toclink" href="#the-pattern-recognition"&gt;The Pattern Recognition&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After years of building systems, these principles become pattern recognition. The key is being intentional about applying them rather than hoping they happen by accident.&lt;/p&gt;
&lt;p&gt;Sean's post does an excellent job distilling complex system design into actionable principles. The challenge is remembering to apply them when you're deep in implementation details.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;What patterns have you noticed in your own system design work? I'd love to hear about principles that have served you well over time.&lt;/p&gt;</content><category term="Development"></category><category term="system-design"></category><category term="software-architecture"></category><category term="database-design"></category><category term="state-management"></category><category term="performance"></category><category term="best-practices"></category></entry><entry><title>The Monolith That Made AI Actually Useful</title><link href="https://ashwch.com/the-monolith-that-made-ai-actually-useful.html" rel="alternate"></link><published>2025-08-07T00:00:00-04:00</published><updated>2025-08-07T00:00:00-04:00</updated><author><name>Ashwini Chaudhary</name></author><id>tag:ashwch.com,2025-08-07:/the-monolith-that-made-ai-actually-useful.html</id><summary type="html">&lt;p&gt;How we solved context switching across multiple repositories by building a monolith using git submodules, making both humans and AI 10x more effective with our codebase.&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;Picture this: You're debugging an issue that spans your React frontend, Django backend, and Terraform infrastructure. Three terminal windows. Three different repos. Three different contexts. By the time you trace the bug from UI to API to database, you've lost half your morning just to context switching.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We solved this at Diversio. The solution made both humans and AI 10x more effective with our codebase.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="table-of-contents"&gt;&lt;a class="toclink" href="#table-of-contents"&gt;Table of Contents&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="#what-youll-learn"&gt;What you'll learn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#the-problem-we-were-facing"&gt;The Problem We Were Facing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#our-solution-git-submodules-done-right"&gt;Our Solution: Git Submodules Done Right&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#the-ai-advantage"&gt;The AI Advantage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#advanced-implementation"&gt;Advanced Implementation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#mcp-integration-and-team-benefits"&gt;MCP Integration and Team Benefits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#the-technical-details"&gt;The Technical Details&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#implementation-strategy"&gt;Implementation Strategy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#the-bottom-line"&gt;The Bottom Line&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="what-youll-learn"&gt;&lt;a class="toclink" href="#what-youll-learn"&gt;What you'll learn&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Structure a monolith&lt;/strong&gt; repository with git submodules for maximum efficiency&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Master git worktrees&lt;/strong&gt; for parallel development without context switching  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Automate worktree creation&lt;/strong&gt; with our Python scripts (links included!)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reduce context switching&lt;/strong&gt; by 90% and watch productivity soar&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Supercharge AI tools&lt;/strong&gt; with complete codebase context—making them actually useful&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Implement immediately&lt;/strong&gt; with practical tips and working code&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you're tired of juggling multiple repos and losing context between features, this guide shows you exactly how we solved it. If you're already using git submodules, you'll learn how to level up with worktrees and automation.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="the-problem-we-were-facing"&gt;&lt;a class="toclink" href="#the-problem-we-were-facing"&gt;The Problem We Were Facing&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Every feature we built touched multiple repositories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clone three separate repos&lt;/li&gt;
&lt;li&gt;Keep versions in sync&lt;/li&gt;
&lt;li&gt;Jump between directories constantly  &lt;/li&gt;
&lt;li&gt;Lose context when debugging cross-service issues&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But here's the real kicker. AI tools like Claude Code couldn't see our full system. They'd suggest fixes that made sense for one service but broke two others. They had fragments, not the full picture.&lt;/p&gt;
&lt;h2 id="our-solution-git-submodules-done-right"&gt;&lt;a class="toclink" href="#our-solution-git-submodules-done-right"&gt;Our Solution: Git Submodules Done Right&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We built a monolith using git submodules that gives us the best of both worlds:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;diversio-monolith/
├── frontend/              # React application
├── backend/               # Django API
├── design-system/         # Shared UI components
├── optimo-frontend/       # Optimo product app
├── diversio-serverless/   # AWS Lambda functions
├── infrastructure/        # Terraform definitions
├── terraform-modules/     # Reusable infrastructure
└── scripts/               # Development automation
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Each directory is its own git repository. But they all live in one workspace. One clone gets you everything.&lt;/p&gt;
&lt;h3 id="from-days-to-hours"&gt;&lt;a class="toclink" href="#from-days-to-hours"&gt;From Days to Hours&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Our product manager &lt;a href="https://www.linkedin.com/in/samuel-bonin/"&gt;Sam&lt;/a&gt; now redesigns features in hours, not days. He pulls the latest code, runs migrations, and has AI analyze our Bruno API collections. Remember when we &lt;a href="https://ashwch.com/from-postman-to-bruno-how-ai-changed-our-api-workflow.html"&gt;migrated from Postman to Bruno&lt;/a&gt;? That decision pays huge dividends in a monolith.&lt;/p&gt;
&lt;p&gt;The workflow looks like this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Pull latest commits across all services&lt;/li&gt;
&lt;li&gt;Run migrations with full database context&lt;/li&gt;
&lt;li&gt;AI reads organized API documentation&lt;/li&gt;
&lt;li&gt;Create comprehensive designs with complete system understanding&lt;/li&gt;
&lt;li&gt;Implement changes knowing exactly what will be affected&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;What used to take hours of repository hopping now happens in a single flow.&lt;/p&gt;
&lt;h2 id="the-ai-advantage"&gt;&lt;a class="toclink" href="#the-ai-advantage"&gt;The AI Advantage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Here's where it gets interesting. By giving AI tools complete system context, we unlocked capabilities that were impossible before:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cross-repository analysis&lt;/strong&gt;: Claude Code traces API calls from frontend to backend to infrastructure&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Better architectural decisions&lt;/strong&gt;: Suggestions consider the entire stack&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;System-wide debugging&lt;/strong&gt;: Issues that span services become traceable&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Smarter refactoring&lt;/strong&gt;: Changes account for all dependencies&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The AI isn't guessing anymore. It knows.&lt;/p&gt;
&lt;h2 id="advanced-implementation"&gt;&lt;a class="toclink" href="#advanced-implementation"&gt;Advanced Implementation&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="git-worktrees-the-secret-sauce"&gt;&lt;a class="toclink" href="#git-worktrees-the-secret-sauce"&gt;Git Worktrees: The Secret Sauce&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The real magic happens with git worktrees. Instead of switching branches and losing context, we work on multiple features simultaneously:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Create a new worktree for a feature&lt;/span&gt;
uv&lt;span class="w"&gt; &lt;/span&gt;run&lt;span class="w"&gt; &lt;/span&gt;scripts/create_worktree.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Our automation handles everything:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Interactive branch selection across all repositories&lt;/li&gt;
&lt;li&gt;Smart filtering for hundreds of branches&lt;/li&gt;
&lt;li&gt;Automatic submodule initialization&lt;/li&gt;
&lt;li&gt;Proper conflict resolution&lt;/li&gt;
&lt;li&gt;Copies .env files (because git worktrees don't do this by default, and nobody wants to debug missing environment variables)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check out our automation scripts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/ashwch/79177b4af7f2ea482418d6e9934d4787"&gt;&lt;strong&gt;create_worktree.py&lt;/strong&gt;&lt;/a&gt; - Interactive worktree creator with submodule support&lt;/li&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/ashwch/909ea473250e8c8a937a8a4aa4a4dc72"&gt;&lt;strong&gt;update_submodules.py&lt;/strong&gt;&lt;/a&gt; - Automated submodule updater with branch configuration&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each developer can have multiple features in progress, each in its own directory, with full system context preserved.&lt;/p&gt;
&lt;h3 id="custom-ai-agents-specialized-tools-for-every-task"&gt;&lt;a class="toclink" href="#custom-ai-agents-specialized-tools-for-every-task"&gt;Custom AI Agents: Specialized Tools for Every Task&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We built specialized Claude Code agents that understand our codebase deeply:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Frontend PR Specialist&lt;/strong&gt;: Analyzes React/TypeScript changes with component architecture visualizations&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Backend PR Specialist&lt;/strong&gt;: Reviews Django changes with database schema analysis&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Infrastructure PR Specialist&lt;/strong&gt;: Validates Terraform changes with cost and security impact assessments  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Integration Specialist&lt;/strong&gt;: Traces data flows across frontend, backend, and infrastructure&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Migration Specialist&lt;/strong&gt;: Handles complex data transformations and migrations&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Testing Automation Specialist&lt;/strong&gt;: Writes comprehensive test suites following our patterns&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each agent has deep knowledge of its domain. They don't just suggest generic fixes. They understand our specific patterns, our conventions, our tech stack.&lt;/p&gt;
&lt;p&gt;We even built meta agents that manage other agents:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Subagent Creator&lt;/strong&gt;: Designs new focused agents with clear boundaries&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Subagent Reviewer&lt;/strong&gt;: Reviews and optimizes agent definitions to prevent overlaps&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These meta agents save hours when adding or updating agents. No more manual agent configuration. The AI helps manage the AI.&lt;/p&gt;
&lt;p&gt;The best part? These agents are shared across the entire team through the monolith. When one engineer creates an agent, everyone benefits immediately.&lt;/p&gt;
&lt;h2 id="mcp-integration-and-team-benefits"&gt;&lt;a class="toclink" href="#mcp-integration-and-team-benefits"&gt;MCP Integration and Team Benefits&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We integrated Model Context Protocol (MCP) servers that give Claude Code direct access to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CircleCI&lt;/strong&gt;: Build status, test results, deployment logs&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Context7&lt;/strong&gt;: Up-to-date documentation for any library&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gemini AI&lt;/strong&gt;: Research and code analysis&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Playwright&lt;/strong&gt;: Browser automation for testing&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These integrations work seamlessly across the entire monolith, giving AI unprecedented visibility into our development pipeline.&lt;/p&gt;
&lt;h3 id="benefits-across-the-team"&gt;&lt;a class="toclink" href="#benefits-across-the-team"&gt;Benefits Across the Team&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Product Managers&lt;/strong&gt; get complete system visibility for rapid prototyping. API documentation and database schemas always accessible.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;New Engineers&lt;/strong&gt; get a single command setup. Clone one repo, get everything with working examples.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Senior Engineers&lt;/strong&gt; can do system-wide refactoring. Make changes across repos with full context.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI Tools&lt;/strong&gt; get complete codebase analysis. Suggestions that actually work.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DevOps teams&lt;/strong&gt; see infrastructure definitions alongside the code they deploy.&lt;/p&gt;
&lt;h2 id="the-technical-details"&gt;&lt;a class="toclink" href="#the-technical-details"&gt;The Technical Details&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Submodule Management&lt;/strong&gt;: Each submodule points to a specific commit. Changes need commits in both the submodule and the monolith. This preserves atomicity while enabling coordination.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Branch Independence&lt;/strong&gt;: Work on different branches in each submodule simultaneously. Perfect for features that need coordinated changes. And crucially, pull requests still go to individual repositories, maintaining our existing review processes and CI/CD pipelines.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Automated Tooling&lt;/strong&gt;: Our Python scripts handle branch management, worktree creation, and submodule updates. No manual coordination needed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API Documentation as Code&lt;/strong&gt;: Bruno's file-based approach means API collections live with the code they test. They're discoverable, version-controlled, and immediately accessible to both humans and AI. The AI can read, understand, and even suggest API changes based on the actual implementation.&lt;/p&gt;
&lt;h2 id="implementation-strategy"&gt;&lt;a class="toclink" href="#implementation-strategy"&gt;Implementation Strategy&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;AI tools are becoming primary development partners. But these tools are only as good as the context you give them. By structuring our codebase for maximum AI comprehension, we created an environment where both humans and AI work at their full potential.&lt;/p&gt;
&lt;p&gt;The results: 10x faster feature development, 90% fewer integration bugs, and architectural decisions that consider the full system impact.&lt;/p&gt;
&lt;h3 id="getting-started"&gt;&lt;a class="toclink" href="#getting-started"&gt;Getting Started&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If you're working with multiple related repositories, you can implement this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a monolith repository&lt;/li&gt;
&lt;li&gt;Add existing repos as git submodules&lt;/li&gt;
&lt;li&gt;Build automation scripts for common workflows&lt;/li&gt;
&lt;li&gt;Configure MCP servers for your tools&lt;/li&gt;
&lt;li&gt;Train your team on git worktrees&lt;/li&gt;
&lt;li&gt;Move API documentation to file-based tools like Bruno&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The investment pays off immediately. No more context switching, better AI assistance, and a development experience that scales with complexity.&lt;/p&gt;
&lt;h2 id="the-bottom-line"&gt;&lt;a class="toclink" href="#the-bottom-line"&gt;The Bottom Line&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This isn't just about tooling. It's about creating an environment where high-quality work happens quickly and naturally.&lt;/p&gt;
&lt;p&gt;When your product managers can redesign systems confidently, your engineers can refactor safely across services, and your AI tools provide system-aware suggestions, you've built more than a development environment.&lt;/p&gt;
&lt;p&gt;You've built a competitive advantage.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Want to dive deeper into Git worktrees? Check out my comprehensive guide: &lt;a href="https://gist.github.com/ashwch/946ad983977c9107db7ee9abafeb95bd"&gt;Git Worktrees: From Zero to Hero&lt;/a&gt;. It covers everything from first principles to advanced workflows with submodules.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Thanks to &lt;a href="https://www.linkedin.com/in/samuel-bonin/"&gt;Samuel Bonin&lt;/a&gt; and &lt;a href="https://www.linkedin.com/in/amalraj-offl/"&gt;Amal Raj&lt;/a&gt; for reviewing this post.&lt;/em&gt;&lt;/p&gt;</content><category term="Development"></category><category term="git-worktrees"></category><category term="development-workflow"></category><category term="ai-tools"></category><category term="monorepo"></category><category term="claude-code"></category><category term="mcp"></category><category term="devops"></category><category term="productivity"></category><category term="bruno"></category></entry></feed>